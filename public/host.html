<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Party Game — Host</title>
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div class="streak"></div>
  <div class="streak s2"></div>
  <div class="streak s3"></div>

  <div class="header">
    <h1 class="title" id="topTitle">Host scherm</h1>
    <div class="subtitle">Room: <span id="roomCode"></span> — <span id="roundNr">Ronde 1</span></div>
  </div>

  <div class="wrap">
    <div class="panel" id="panel">
      <div class="panelInner" id="panelInner">

        <!-- LEFT (Lobby only): Join -->
        <div class="card" id="joinCard">
          <div class="joinTop">
            <div class="viewTitle">Join</div>
            <div class="roomPill">Room: <strong id="roomCode2"></strong></div>
          </div>

          <div class="qrWrap">
            <div class="qrGlow"></div>
            <img id="qr" alt="QR code" />
          </div>

          <div style="margin-top: 12px;">
            <div class="muted" style="margin-bottom:6px;">Join link:</div>
            <code id="joinLink"></code>
          </div>

          <div class="btnRow">
            <button class="btn" id="startBtn" disabled>Start game</button>
          </div>

          <div class="muted" id="hostHint" style="margin-top:10px;"></div>
          <div class="errors" id="errors"></div>
        </div>

        <!-- RIGHT: Main -->
        <div class="card" id="mainCard">

          <!-- LOBBY -->
          <div id="viewLobby">
            <div class="rightTop">
              <div>
                <div class="viewTitle">Spelers</div>
                <div class="muted">Iedereen ready? Dan kun je starten.</div>
              </div>
              <div class="count"><span id="count">0</span> / <span id="max">6</span></div>
            </div>
            <div class="slots" id="slots"></div>
          </div>

          <!-- ANSWERING -->
          <div id="viewAnswering" style="display:none;">
            <div class="viewTitle">Invullen…</div>
            <div class="muted">Telefoons: beantwoord de stelling op het scherm.</div>
            <div class="muted" style="margin-top:10px;"><strong id="progress"></strong></div>
          </div>

          <!-- REVEAL (presentation) -->
          <div id="viewReveal" style="display:none;">
            <div class="viewTitle">Reveal</div>

            <div class="revealBox">
              <div class="muted" id="targetLabel"></div>
              <div class="bigAnswer" id="targetAnswer"></div>

              <div class="predStage" id="predStage">
                <div class="predLine">
                  <div class="predName" id="predName"></div>
                  <div class="predAns" id="predAns"></div>
                </div>

                <div class="pointPop" id="pointPop">+1</div>
              </div>

              <div style="margin-top:14px;">
                <button class="btn" id="nextRevealBtn">Volgende speler</button>
              </div>
            </div>
          </div>

          <!-- SCOREBOARD -->
          <div id="viewScore" style="display:none;">
            <div class="viewTitle">Scoreboard</div>

            <table>
              <thead>
                <tr><th>Speler</th><th>Score</th></tr>
              </thead>
              <tbody id="scoreRows"></tbody>
            </table>

            <div style="margin-top:14px;">
              <button class="btn btnSecondary" id="nextQuestionBtn">Volgende vraag</button>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const roomCode = location.pathname.split("/").pop().toUpperCase();
    document.getElementById("roomCode").textContent = roomCode;
    document.getElementById("roomCode2").textContent = roomCode;

    const joinUrl = `${location.origin}/join/${roomCode}`;
    document.getElementById("joinLink").textContent = joinUrl;

    fetch(`/api/qr?text=${encodeURIComponent(joinUrl)}`)
      .then(r => r.json())
      .then(data => { if (data.dataUrl) document.getElementById("qr").src = data.dataUrl; });

    const socket = io();
    socket.emit("hostSubscribe", { roomCode });

    // Buttons
    const startBtn = document.getElementById("startBtn");
    const nextRevealBtn = document.getElementById("nextRevealBtn");
    const nextQuestionBtn = document.getElementById("nextQuestionBtn");

    startBtn.onclick = () => socket.emit("hostStartGame", { roomCode });
    nextRevealBtn.onclick = () => socket.emit("hostNextReveal", { roomCode });
    nextQuestionBtn.onclick = () => socket.emit("hostNextQuestion", { roomCode });

    // animation state
    let lastTargetId = null;
    let playToken = 0;

    socket.on("errorMessage", (msg) => {
      document.getElementById("errors").textContent = msg;
    });

    socket.on("roomState", (state) => {
      document.getElementById("max").textContent = state.maxPlayers;
      document.getElementById("count").textContent = state.players.length;

      // UX-bonus: ronde + vraag in subtitle
      document.getElementById("roundNr").textContent =
        state.question
          ? `Ronde ${state.round} — Vraag ${state.question}/${state.questionsPerRound}`
          : `Ronde ${state.round ?? 1}`;

      renderSlots(state.players);

      // Title: prompt zodra game gestart is
      const topTitle = document.getElementById("topTitle");
      if (state.state === "LOBBY") topTitle.textContent = "Host scherm";
      else topTitle.textContent = state.prompt || "…";

      // QR only in lobby
      setLobbyLayout(state.state === "LOBBY");

      // Startknop (alleen lobby)
      const connected = state.players.filter(p => p.connected);
      const canStart = (state.state === "LOBBY")
        && connected.length >= 2
        && connected.every(p => p.ready);

      startBtn.disabled = !canStart;

      showView(state.state);

      if (state.state === "ANSWERING") {
        document.getElementById("progress").textContent =
          `${state.submissionsCount || 0} / ${state.players.length} antwoorden binnen`;
      }

      if (state.state === "REVEAL") {
        const rd = state.revealData;
        if (!rd) return;

        document.getElementById("targetLabel").textContent = `Antwoord van ${rd.targetName}`;
        document.getElementById("targetAnswer").textContent = rd.targetAnswer || "(leeg)";

        // start animatie opnieuw bij nieuwe target
        if (rd.targetId !== lastTargetId) {
          lastTargetId = rd.targetId;
          playRevealPredictors(rd.predictors);
        }
      }

      if (state.state === "SCOREBOARD") {
        renderScoreboard(state.players);

        const q = state.question || 0;
        const total = state.questionsPerRound || 10;
        const isLastQuestion = q >= total;

        nextQuestionBtn.textContent = isLastQuestion
          ? "Nieuwe ronde"
          : `Volgende vraag (${q + 1}/${total})`;
      }

      document.getElementById("hostHint").textContent =
        (state.state === "LOBBY") ? "Tip: iedereen moet Ready zijn (min. 2 spelers) om te starten." : "";
      document.getElementById("errors").textContent = "";
    });

    function setLobbyLayout(isLobby) {
      const joinCard = document.getElementById("joinCard");
      const panelInner = document.getElementById("panelInner");

      if (isLobby) {
        joinCard.style.display = "block";
        panelInner.style.gridTemplateColumns = "360px 1fr";
      } else {
        joinCard.style.display = "none";
        panelInner.style.gridTemplateColumns = "1fr";
      }
    }

    function showView(gameState) {
      document.getElementById("viewLobby").style.display = (gameState === "LOBBY") ? "block" : "none";
      document.getElementById("viewAnswering").style.display = (gameState === "ANSWERING") ? "block" : "none";
      document.getElementById("viewReveal").style.display = (gameState === "REVEAL") ? "block" : "none";
      document.getElementById("viewScore").style.display = (gameState === "SCOREBOARD") ? "block" : "none";
    }

    function renderSlots(players) {
      const wrap = document.getElementById("slots");
      if (!wrap) return;
      wrap.innerHTML = "";

      for (let i = 0; i < 6; i++) {
        const p = players[i];
        const div = document.createElement("div");

        if (!p) {
          div.className = "slot slotEmpty";
          div.innerHTML = `<div class="slotName">?</div>`;
          wrap.appendChild(div);
          continue;
        }

        const statusClass = !p.connected
          ? "slotOffline"
          : (p.ready ? "slotReady" : "slotNotReady");

        div.className = `slot ${statusClass}`;
        div.title = p.connected ? (p.ready ? "Ready" : "Niet ready") : "Offline";
        div.innerHTML = `<div class="slotName">${escapeHtml(p.name)}</div>`;
        wrap.appendChild(div);
      }
    }

    function renderScoreboard(players) {
      const rows = document.getElementById("scoreRows");
      rows.innerHTML = "";

      [...players]
        .sort((a,b) => (b.score||0) - (a.score||0))
        .forEach(p => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${escapeHtml(p.name)}</td><td>${p.score || 0}</td>`;
          rows.appendChild(tr);
        });
    }

    // Reveal animation: 1 predictor at a time (5 seconds total)
    async function playRevealPredictors(predictors) {
      playToken++;
      const token = playToken;

      const stage = document.getElementById("predStage");
      const predName = document.getElementById("predName");
      const predAns = document.getElementById("predAns");
      const pointPop = document.getElementById("pointPop");

      stage.classList.remove("fadeIn","fadeOut");
      predName.textContent = "";
      predAns.textContent = "";
      pointPop.classList.remove("pop");

      if (!predictors || predictors.length === 0) return;

      // total ~5.0s per predictor
      const FADE_IN = 300;
      const SHOW = 3200;
      const POP = 1200;
      const FADE_OUT = 300;

      for (const p of predictors) {
        if (token !== playToken) return;

        predName.textContent = `${p.predictorName} voorspelde`;
        predAns.textContent = p.predicted || "(leeg)";

        stage.classList.remove("fadeOut");
        stage.classList.add("fadeIn");
        await wait(FADE_IN);

        await wait(SHOW);

        if (p.match) {
          pointPop.classList.add("pop");
          await wait(POP);
          pointPop.classList.remove("pop");
        } else {
          await wait(180);
        }

        stage.classList.remove("fadeIn");
        stage.classList.add("fadeOut");
        await wait(FADE_OUT);
      }

      if (token !== playToken) return;
      predName.textContent = "";
      predAns.textContent = "";
      stage.classList.remove("fadeIn","fadeOut");
    }

    function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[s]));
    }
  </script>
</body>
</html>
